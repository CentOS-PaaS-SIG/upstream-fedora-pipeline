#!groovy

timestamps {
    def libraries = ['cico-pipeline'           : ['master', 'https://github.com/CentOS/cico-pipeline-library.git'],
                     'contra-lib'              : ['master', 'https://github.com/openshift/contra-lib.git'],
                     'upstream-fedora-pipeline': ['master', 'https://github.com/CentOS-PaaS-SIG/upstream-fedora-pipeline.git']]

    libraries.each { name, repo ->
        library identifier: "${name}@${repo[0]}",
                retriever: modernSCM([$class: 'GitSCMSource',
                                      remote: repo[1]])

    }

    // Audit file for all messages sent.
    msgAuditFile = "messages/message-audit.json"

    // Number of times to keep retrying to make sure message is ingested
    // by datagrepper
    fedmsgRetryCount = 120

    //noinspection GroovyAssignabilityCheck
    properties(
            [
                    buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '100', daysToKeepStr: '', numToKeepStr: '100')),
                    disableConcurrentBuilds(),
                    pipelineTriggers(
                            [[$class: 'CIBuildTrigger',
                              noSquash: true,
                              providerData: [
                                  $class: 'FedMsgSubscriberProviderData',
                                  name: 'fedora-fedmsg',
                                  overrides: [
                                      topic: 'org.fedoraproject.prod.pagure.pull-request.comment.added'
                                  ],
                                  checks: [
                                      [field: '$.pullrequest.project.namespace', expectedValue: 'container']
                                  ]
                              ]
                            ]]
                    ),

                    parameters(
                            [
                                    string(defaultValue: '', description: 'CI_MESSAGE', name: 'CI_MESSAGE')
                            ]
                    )
            ]
    )

    def TRIGGER_RETRY_COUNT = 3
    def validMessage = true
    def stepName = null

    node('master') {

        // pull in ciMetrics from ci-pipeline
        // ciMetrics.prefix = packagepipelineUtils.influxDBPrefix()
        // packagepipelineUtils.cimetrics = ciMetrics
        // def jobMeasurement = packagepipelineUtils.timedMeasurement()


        timeout(time: 30, unit: 'MINUTES') {

            packagepipelineUtils.ciPipeline {
                try {
                    stepName = 'fedora-container-pr-trigger'
                    stage(stepName) {

                        packagepipelineUtils.handlePipelineStep(stepName: stepName, debug: true) {

                            print "CI_MESSAGE"
                            print CI_MESSAGE

                            packagepipelineUtils.setDefaultEnvVars()
                            parsedMsg = kojiMessage(message: env.CI_MESSAGE, ignoreErrors: true)
                            currentBuild.displayName = "BUILD#: ${env.BUILD_NUMBER} - Branch: ${parsedMsg['pullrequest']['branch']} - Package: ${parsedMsg['pullrequest']['project']['name']}"
                            validMessage = packagepipelineUtils.checkBranch(parsedMsg['pullrequest']['branch'])
                            env.branch = (parsedMsg['pullrequest']['branch'] == 'master') ? 'rawhide' : parsedMsg['pullrequest']['branch']
                            testsExist = packagepipelineUtils.checkTests(parsedMsg['pullrequest']['project']['name'], parsedMsg['pullrequest']['branch'], 'container', (parsedMsg['pullrequest'].has('id') ? parsedMsg['pullrequest']['id'] : null), 'container')
                            // Function only returns false if comments exist,
                            // but the latest was uninteresting
                            commentTrigger = packagepipelineUtils.checkUpdatedPR(env.CI_MESSAGE, '[citest]')
                        }
                    }

                    if (validMessage && testsExist && commentTrigger) {
                        // Since pipeline is only functional test stage,
                        // send the message for that stage
                        messageFields = packagepipelineUtils.setMessageFields('container.test.functional.queued', 'pr')
                        //sendMessageWithAudit(msgTopic: messageFields['topic'], msgProps: messageFields['properties'], msgContent: messageFields['content'], msgRetryCount: fedmsgRetryCount)

                        stepName = 'schedule build'
                        stage(stepName) {

                            try {
                                retry(TRIGGER_RETRY_COUNT) {
                                    packagepipelineUtils.handlePipelineStep(stepName: stepName, debug: true) {
                                        build job: "fedcontainer-${env.branch}-pr-pipeline",
                                                parameters: [string(name: 'CI_MESSAGE', value: env.CI_MESSAGE)],
                                                wait: false
                                    }

                                }
                            } catch (Throwable err) {
                                currentBuild.description = "*TRIGGER FAILURE*"
                                error "Error: Build could not be added to queue after " + TRIGGER_RETRY_COUNT + " tries"
                                throw err
                            }
                        }

                    } else {
                        echo "CI_MESSAGE was invalid. Skipping..."
                        messageFields = packagepipelineUtils.setMessageFields('container.ignored', 'pr')
                        //sendMessageWithAudit(msgTopic: messageFields['topic'], msgProps: messageFields['properties'], msgContent: messageFields['content'], msgRetryCount: fedmsgRetryCount)
                        currentBuild.description = "*Build Skipped*"
                    }

                    currentBuild.result = 'SUCCESS'

                } catch (Throwable err) {
                    currentBuild.result = 'FAILURE'
                    throw err
                }
            }
        }
    }
}
